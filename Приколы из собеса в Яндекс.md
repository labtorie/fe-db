### Задача 1

Тут прикол в том, что попросят решение ES5, которое подразумевает знание ключевого слова `arguments`. Внутри функции оно возвращает array-like object  с аргументами, с которыми функцию вызвали

``` javascript
joinStr('-', '1', '2', '3', '4') // '1-2-3-4'

//ES6 
function joinStr (delimeter, ...strings) {
	return strings.join(delimeter)
} 

// ES5 
function joinStr (delimeter) {
	const strings = new Array(arguments).slice(1)
	// Или итерироваться по iterable collection arguments
	
	return strings.join(delimeter)
}
```

### Задача 2

Тут каррирование, где потребуется знание свойства `.length` у функции

> `fn.length` => возвращает количество аргументов, которая функция ожидает. Если в объявлении параметров функции стоит rest оператор, вернет 0

``` js
function sum (a,b,c) {
	return a + b + c
}

function curry(fn) {
	const accumulatedArgs = []
	
	const curried = function (...args) {
		accumulatedArgs.push(...args)
		if (accumulatedArgs.length >= fn.length) {
			return fn(...accumulatedArgs)
		} else {
			return curried
		}
	}
	
	return curried
}

curry(sum)(1,2,3,4,5) // 6; 4,5 is ignored
curry(sum)(1)(2)(3) // 6
curry(sum)(1, 2)(3) // 6
```

### Задача 3

Важно учесть, что fn может вернуть и rejected. Еще можно решить через Promise.race, наверное
``` js
// Функция timeLimited, возвращает экземпляр fn с механизмом timeout, который реджектит ошибку по истечении времени. 

function timeLimited(fn, t) {
	return function (...args) {
		return new Promise((resolve, reject) => {
			const timer = setTimeout(() => reject('Time limit exceeded'), t);
			
			return fn(...args)
				.then(resolve)
				.catch(reject)
				.finally(() => clearTimeout(timer));
		});
	};
}

```

### Задача 4

Тут нужно написать функцию, которая находит пересечения в онлайне двух пользователей. Данные представлены в виде массивов тандемов вида `[online, offline]`
То есть лог пользователя выглядит так: `[0, 3], [4, 7], [8, 12]`
Время может быть от 0 до 24. Не сказано, что оно обязательно целое. 
Функция должна принимать два таких набора в себя для двух пользователей и выводить набор, когда оба были онлайн. 

Если решать в лоб, то нужно внутри цикла по первому пользователю гонять цикл по второму. Сложность будет O(n^2) 

Мое решение ниже. Интуиция подсказала, что тут подойдет подход с двумя указателями. 
Логика в том, что можно попытаться найти пересечение у каждой пары, но у правильного пересечения время конца будет больше времени начала. 
Также, после каждой итерации обязательно нужно увеличить один из указателей, и это мы определяем по тому, у кого меньше время окончания (с ним уже нет шансов найти пересечение, время вышло, смотрим следующее). Находимся в цикле, пока оба итератора не достигли конца своих массивов. 

Сложность, по идее, О(n+m), M(max(n,m))

``` js
function timeIntersection(time1, time2) {
  return [Math.max(time1[0], time2[0]), Math.min(time1[1], time2[1])];
}

function intersection(user1, user2) {
  const onlineTimes = [];
  let i = 0,
    j = 0;

  while (i < user1.length && j < user2.length) {
    const [online, offline] = timeIntersection(user1[i], user2[j]);
    if (online < offline) {
      onlineTimes.push([online, offline]);
    }
    if (user1[i][1] < user2[j][1]) {
      i++;
    } else {
      j++;
    }
  }
  return onlineTimes;
}


// [4,7], [8,12]
// [3,5], [6,9], [11, 15]
// [4,5], [6,7], [8,9], [11,12]

let res = intersection(
  [
    [0, 3],
    [4, 7],
    [8, 12],
  ],
  [
    [0,7],
    [8, 9],
    [11, 15],
  ]
);

console.log(res);
```