## Этап 1 - База
### Задача 1 - ES5

Тут прикол в том, что попросят решение ES5, которое подразумевает знание ключевого слова `arguments`. Внутри функции оно возвращает array-like object  с аргументами, с которыми функцию вызвали

``` javascript
joinStr('-', '1', '2', '3', '4') // '1-2-3-4'

//ES6 
function joinStr (delimeter, ...strings) {
	return strings.join(delimeter)
} 

// ES5 
function joinStr (delimeter) {
	const strings = new Array(arguments).slice(1)
	// Или итерироваться по iterable collection arguments
	
	return strings.join(delimeter)
}
```

### Задача 2 - curry

Тут каррирование, где потребуется знание свойства `.length` у функции

> `fn.length` => возвращает количество аргументов, которая функция ожидает. Если в объявлении параметров функции стоит rest оператор, вернет 0

``` js
function sum (a,b,c) {
	return a + b + c
}

function curry(fn) {
	const accumulatedArgs = []
	
	const curried = function (...args) {
		accumulatedArgs.push(...args)
		if (accumulatedArgs.length >= fn.length) {
			return fn(...accumulatedArgs)
		} else {
			return curried
		}
	}
	
	return curried
}

curry(sum)(1,2,3,4,5) // 6; 4,5 is ignored
curry(sum)(1)(2)(3) // 6
curry(sum)(1, 2)(3) // 6
```

### Задача 3 - Promises

Важно учесть, что fn может вернуть и rejected. Еще можно решить через Promise.race, наверное
``` js
// Функция timeLimited, возвращает экземпляр fn с механизмом timeout, который реджектит ошибку по истечении времени. 

function timeLimited(fn, t) {
	return function (...args) {
		return new Promise((resolve, reject) => {
			const timer = setTimeout(() => reject('Time limit exceeded'), t);
			
			return fn(...args)
				.then(resolve)
				.catch(reject)
				.finally(() => clearTimeout(timer));
		});
	};
}

```

### Задача 4 - array intersect

Тут нужно написать функцию, которая находит пересечения в онлайне двух пользователей. Данные представлены в виде массивов тандемов вида `[online, offline]`
То есть лог пользователя выглядит так: `[0, 3], [4, 7], [8, 12]`
Время может быть от 0 до 24. Не сказано, что оно обязательно целое. 
Функция должна принимать два таких набора в себя для двух пользователей и выводить набор, когда оба были онлайн. 

Если решать в лоб, то нужно внутри цикла по первому пользователю гонять цикл по второму. Сложность будет O(n^2) 

Мое решение ниже. Интуиция подсказала, что тут подойдет подход с двумя указателями. 
Логика в том, что можно попытаться найти пересечение у каждой пары, но у правильного пересечения время конца будет больше времени начала. 
Также, после каждой итерации обязательно нужно увеличить один из указателей, и это мы определяем по тому, у кого меньше время окончания (с ним уже нет шансов найти пересечение, время вышло, смотрим следующее). Находимся в цикле, пока оба итератора не достигли конца своих массивов. 

Сложность, по идее, О(n+m), M(max(n,m))

``` js
function timeIntersection(time1, time2) {
  return [Math.max(time1[0], time2[0]), Math.min(time1[1], time2[1])];
}

function intersection(user1, user2) {
  const onlineTimes = [];
  let i = 0,
    j = 0;

  while (i < user1.length && j < user2.length) {
    const [online, offline] = timeIntersection(user1[i], user2[j]);
    if (online < offline) {
      onlineTimes.push([online, offline]);
    }
    if (user1[i][1] < user2[j][1]) {
      i++;
    } else {
      j++;
    }
  }
  return onlineTimes;
}


// [4,7], [8,12]
// [3,5], [6,9], [11, 15]
// [4,5], [6,7], [8,9], [11,12]

let res = intersection(
  [
    [0, 3],
    [4, 7],
    [8, 12],
  ],
  [
    [0,7],
    [8, 9],
    [11, 15],
  ]
);

console.log(res);
```

## Этап 2 - Алгоритмы
### Задача 1 - array grouping

Нужно написать алгоритм, который группирует числа в массиве. Условия группировки - числа в группе должны быть "омонимами", то есть из цифр одного можно составить другое. Нули при этом игнорируются, так как число 0123 не имеет смысла (интерпретировать как 123). 

В задачах на группировку сразу хочется начать с создания мапы. 
Сложность в том, чтоб выбрать ключи этой мапы. Первым делом захотелось привести число к строке, отбросить нули, отсортировать по цифрам. 

Можно оптимизировать нахождение ключа способом ниже. 

```js
function getKeyFast(number) {
  // Оптимизированная версия, время O(n), память O(1)
  const digitFrequency = new Array(9).fill(0);

  while (number !== 0) {
    const remainder = number % 10;
    if (remainder !== 0) {
      digitFrequency[remainder-1]++;
    }
    number = Math.floor(number / 10);
  }

  return digitFrequency.join('');
}


function getKey(number) {
  // Это решение в лоб, оно не самое эффективное, потому что тут сортировка. O(n log n) time, O(n) auxiliary space
  return [...number.toString()]
    .filter(char => char !== '0')
    .sort()
    .join('');
}

function digitPermutation(arr) {
  const map = {};

  for (const number of arr) {
    const key = getKeyFast(number);
    map[key] = [...(map[key] ?? []), number];
  }

  return Object.keys(map);
}


console.log(
  digitPermutation([1230, 99, 23001, 123, 111, 300021, 101010, 90000009, 9])
);
console.log(digitPermutation([11, 22]));
console.log(digitPermutation([122222, 1111111112]));

```

### Задача 2 - throttle + debounce

> Напишите функцию throttle(fn,  delay, ctx) - "тормозилку", которая возвращает обертку, вызывающую fn не чаще, чем раз в delay мс.
> В качестве контекста используется ctx
> Первый вызов fn всегда должен быть синхронным.
> Если игнорируемый вызов оказался последним, то он должен выполниться

```
пример для delay === 100
. - вызовы throttledFn
! - вызовы fn

0ms       100ms     200ms
.................
!          !          !

0ms       100ms     200ms
.   .   .          . 
!          !          !

```

Рассуждения следующие
У throttled функции есть 3 состояния:
1. Ее вызвали, и ей можно быть вызванной
2. Ее вызвали, но ей нельзя быть вызванной
3. Ей стало можно быть вызванной, вызывается последний колл

```js
function throttle(fn, delay, ctx) {
  let isThrottled = false;
  let scheduledArgs; // параметры последнего вызова

  const throttledFn = (...args) => {
    if (isThrottled) {
      scheduledArgs = args;
      return;
    }

    isThrottled = true;

    setTimeout(() => {
      isThrottled = false;
      if (scheduledArgs) {
        throttledFn(...scheduledArgs);
        scheduledArgs = undefined;
      }
    }, delay);

    return fn.call(ctx, ...args);
  };

  return throttledFn;
}

function test() {
  const start = Date.now();

  function log(text) {
    const msPassed = Date.now() - start;
    console.log(`${msPassed}: ${this.name} logged ${text}`);
  }

  const throttled = throttle(log, 100, { name: 'me' });

  setTimeout(() => throttled('m'), 0);
  setTimeout(() => throttled('mo'), 22);
  setTimeout(() => throttled('mos'), 33);
  setTimeout(() => throttled('mosc'), 150);
  setTimeout(() => throttled('moscow'), 350);

  //   0ms: me logged m
  // 100ms: me logged mos
  // 400ms: me logged moscow
}

test();

```